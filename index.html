<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <link rel="stylesheet" type="text/css" href="stylesheets/customs.css" media="screen">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Multi Process Background Engine by Alex Nudelman </title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <div class="inner-image"></div>
          <h1> Multi Processing Background Worker Engine </h1>
          <h2> <span class="ruby-icon"></span> Ruby multi process module by Alex Nudelman (<a href="https://github.com/nudelx" class="user-mention" >@nudelx</a>)</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/nudelx/ParallelWorker/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/nudelx/ParallelWorker/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/nudelx/ParallelWorker" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>About the Project</h3>

<p>Multi Process module / Background Worker allows you to run multiple tasks or processes in parallel mode.
The parallel mode is implemented with *nix process <strong>fork</strong>.
In computing, particularly in the context of the Unix operating system and its workalikes,
fork is an operation whereby a process creates a copy of itself. It is usually a system call, implemented in the kernel.
<a href="https://guides.github.com/features/mastering-markdown/"></a>
<strong>fork()</strong> creates a child process that differs from the parent process only in its PID and PPID.
Under Linux, fork() is implemented using copy-on-write pages, so the only penalty that it incurs is the time and memory required to duplicate the parentâ€™s page tables, and to create a unique task structure for the child.
ParallelWorker gives you ability to setup bunch of tasks and provide callback function to each of them. In addition to the callback function you can provide external object hash like,
where the attributes can a data structure or individual functionality for each task. ParallelWorker will distribute the tasks during managing the process queue.
In current version you can control the number of on-line processes by setting the max process limit. Once max process limit will be exceeded the the engine will activate wait mode.
In wait mode engine will listen for task are done with the job and then will put the next one from the queue and so on. So every single tick you will see x numbers of task on-line,
according to the limit you can set, and the (n-x) task in queue waiting to run.</p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Class Description - Public Methods</h3>

<p>
 <strong>set_data </strong>
   - The method provides access to the data value, where you can store the bunch of tasks in array.
  <br><br>Example:
  <pre>set_data(data: 255.times.map{|i| "192.168.1.#{i}"})</pre>
  Will set data array with class <C> of IP addresses
</p>

<p>
 <strong>max_proc </strong>
   - Assessor to set the on-line process limit
  <code>
    max_proc = 10
  </code> Will set the limit up to 10 live processes on-line
</p>

<p>
 <strong>set_callback</strong>
   - Method provides access to the call lambda function to be executed by the process.
  <br><br>Example:
  <pre>
    set_callback( callback: lambda { |ip_address , ext_obj|

        out  = system("ping -c 1 -o -t 1 #{ip_address} | 2>&1 >> /dev/null")
        if out
          puts "Host #{ip_address} is alave\n"
        else
          puts "Host #{ip_address} is dead\n"
    end
    })
  </pre>
  Lambda function will be called by the fork process with arguments "ip_address" in our case, according to the data set above.
  The process will run system command and do the logics.

</p>

<p>
 <strong>set_ext_obj</strong>
   - Method provides access special extra hash object. Where you can set all kind of
   business logics or special unique/diffident functionality for each processes.
   As a callback, extra object can be accessible inside the fork process, where you can execute
   it by a key or any other parameter of or choice.
  <br><br>Example:
  <pre>
    PW.set_ext_obj(ext_obj: {
      'function_a' =>  lambda{ puts "hello I am extra function"},
      'array' => [0,1,2,3,4,5,6,7],
      'hash' => {  'A' => 1, 'B' => 1, 'C' => 1,  },
      'value' => 'some value'
    })
  </pre>

  The extra object can be executed from callback function, where it will be passed as a second argument.
  <br><br>Example:
  <pre>
    PW.set_callback(callback: lambda { |item , ext_obj|

      File.open("#{Process.pid}.txt", "w") { |file|

          file.write("Hello from child process #{Process.pid}
                      wait time: #{sleep 5*item}(s)
                      #{pp ext_obj}
                      bye bye ..."
                    )
      }
})


  ### And this is a content of a process.pid.txt for example:

  Hello from child process 83510
  wait time: 10(s)
  {
    "function_a" => (lambda),
    "array"     => [0, 1, 2, 3, 4, 5, 6, 7],
    "hash"      => {"A"=>1, "B"=>1, "C"=>1},
    "value"     => "some value"
  }

  bye bye ...

  </pre>

</p>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
Use Cases and Examples:</h3>

<p>In order to make it more clearly, you can review couple of examples: </p>

<dl>
  <dt><strong>1 - File: [example.rb] </strong></dt>
  <dd>
    This example file will run 1..10 processes, where each process will run callback function.
    Callback will wait (sleep 5*item ) where item is array index , and print some text on the screen
    all this will run in debug mode.
    ** note: debug mode is a kind of slow motion each one iteration in one second
    see sleep 1 in debug function.
    <br><br>Example:
    <pre>
    #!/usr/bin/env ruby

    require './ParallelWorker'

    PW = ParallelWorker.new()
    PW.debug_mode = true
    PW.set_callback(callback: lambda {|item,ext_obj| sleep 5*item ;
                                      puts "Done ,,,
                                      I am dead my Pid is #{Process.pid}"})
    PW.set_data(data: (1..10).to_a)
    PW.run()
    </pre>
   </dd>
   <dt><strong>2 - File: [example_network_scan.rb] </strong></dt>
  <dd>
    <br>
    NETWORK DISCOVERY<br>
    This example file will run 255 nmap scan processes, with max processes limit 10, after the limit will be exceeded, engine will
    activate the queue management where first finished process will yield the spot for next one waiting in the queue.
    Each process will run callback function.
    The Callback will run nmap scan on each item, where item is IP address of subnetwork 192.168.1.1-255.
    after the scan, result will be stored in the text file for future usage.

    <br><br>Example:
    <pre>
    #!/usr/bin/env ruby
    require './ParallelWorker'

    PW = ParallelWorker.new()
    PW.max_proc = 10

    PW.set_callback(callback: lambda { |ip_address , ext_obj|

    out  = `sudo nmap -O -A --script snmp-interfaces #{ip_address} -oN ./data-files/#{ip_address}.txt`

    })
    PW.set_data(data: 255.times.map{|i| "192.168.1.#{i}"})
    PW.run()
    </pre>
   </dd>
      <dt><strong>3 - File: [example_ping_to_class_c.rb] </strong></dt>
     <dd>
    <br>
    DHCP Pulling<br>
    This example file will run 255 ping checks, with max processes limit 10,
    The Callback will run ping check on each item, where item is IP address of subnetwork 192.168.1.1-255.
    The check will return 0 if check was positive or 2 if no answer.
    This is simple utility to see the DHCP active clients

    <br><br>Example:
    <pre>
    require './ParallelWorker'

    PW = ParallelWorker.new()
    PW.max_proc = 10

    PW.set_callback(callback: lambda { |ip_address , ext_obj|

    out  = system("ping -c 1 -o -t 1 #{ip_address} | 2>&1 >> /dev/null")

    if out == 0 ### $? exit code
      puts "Host #{ip_address} is alave\n"
    else
      puts "Host #{ip_address} is dead\n"
    end
  })
  PW.set_data(data: 255.times.map{|i| "192.168.1.#{i}"})
  PW.run()
    </pre>
   </dd>

<dt><strong>4 - File: [example_remote_ssh_command.rb] </strong></dt>
     <dd>
    <br>
    SSH Remote Command<br>
    This example file will run on 255 hosts , with max processes limit 10,
    The Callback will execute remote ssh command and print the output in the console

    <br><br>Example:
    <pre>
    #!/usr/bin/env ruby
    require './ParallelWorker'

    PW = ParallelWorker.new()
    PW.max_proc = 10
    PW.debug_mode = true
    PW.set_callback(callback: lambda { |ip_address , ext_obj|
      puts "ssh command to  root@#{ip_address}"
      out  = ` ssh root@#{ip_address} netstat -an | grep -i listen`
      puts out
    })
    PW.set_data(data: 255.times.map{|i| "192.168.1.#{i}"})
    PW.run()
    </pre>
   </dd>

   <dt><strong>5 - File: [example_with_files.rb] </strong></dt>
     <dd>
    <br>
    Extra Object Example<br>
    This example shows the usage of extra object , where extra object can hold any extra / unique
    functionality for each process, that gives the ability to provide
    a different function for each process according to the needs

    <br><br>Example:
    <pre>
    #!/usr/bin/env ruby
    require './ParallelWorker'

    PW = ParallelWorker.new()
    PW.set_ext_obj(ext_obj: {
        'function_a' =>  lambda{ puts "hello I am extra function"},
        'array' => [0,1,2,3,4,5,6,7],
        'hash' => {  'A' => 1, 'B' => 1, 'C' => 1,  },
        'value' => 'some value'
      }
    )
  PW.set_callback(callback: lambda { |item , ext_obj|
      File.open("#{Process.pid}.txt", "w") { |file|
          file.write("Hello from child process #{Process.pid}\nwait time: #{sleep 5*item}(s)\n #{pp ext_obj} bye bye ...")
      }
  })
  PW.set_data(data: (1..10).to_a)
  PW.run()
    </pre>
   </dd>


</dl>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
Helpers and Monitoring Scripts</h3>

<p>

  There is two shell script provided with the module:

  <ul class="custom-list">
    <li>
      <strong>monitor_process.sh: => </strong> to monitor the number of a running processes
    </li>

    <li>
      <strong>monitor_zombies.sh: => </strong> to monitor the zombies if some thing goes wrong
    </li>
  </ul>

</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
Authors and Contributors</h3>

<p>A first version of the ParallelWorker was created and designed by Alex Nudelman <a href="https://github.com/nudelx" class="user-mention">(@nudelx)</a>.
In order to make it more powerful and useful, you are welcome to visit the github page and comment/fork the project or become a contributer.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with the Module? you know the address :)</p>
        </section>

        <footer>
          Multi Process / Background Engine  is maintained by <a href="https://github.com/nudelx">nudelx</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>


      </div>
    </div>
  </body>
</html>
